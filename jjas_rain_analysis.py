# -*- coding: utf-8 -*-
"""JJAS Rain Analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16OkN_KDOxP2RoB4wOIrcLVJy9KXeRvhL
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import sklearn

from google.colab import drive
drive.mount('/content/drive')

df = pd.read_csv('/content/drive/MyDrive/POWER_Point_Daily_19810101_20240430_012d97N_077d59E_LST (1).csv')

"""# data cleaning"""

df.head()

df = df.drop(df.index[:19])

select = ['-BEGIN HEADER-','Unnamed: 1','Unnamed: 5']
ndf = df[select]
ndf.head()

cols = ['year','dayno.','rainfall']
ndf.columns = cols
ndf.head()

ndf.apply(pd.isnull).sum()

"""# taking value of days from june to september"""

ndf.loc[:, 'rainfall'] = ndf['rainfall'].astype(float)
ndf.loc[:, 'year'] = ndf['year'].astype(int)
total = ndf['rainfall'].sum()
total

# Convert 'dayno.' column to integer
ndf['dayno.'] = ndf['dayno.'].astype(int)
selected_days = ndf[(ndf['dayno.'] >= 150) & (ndf['dayno.'] <= 250)]
jjs_rain_sum = selected_days.groupby('year')['rainfall'].sum().reset_index()

jjs_rain_sum

plt.figure(figsize=(12, 6))
plt.plot(jjs_rain_sum['year'], jjs_rain_sum['rainfall'],  linestyle='-', color='blue', label='Actual Rainfall')
plt.title('Time Series of Rainfall from 1981 to 2023')
plt.xlabel('Year')
plt.ylabel('Rainfall (mm)')
plt.grid(True)
plt.legend()
plt.show()

"""# SVM prediction model"""

import matplotlib.pyplot as plt

# Assuming jjs_rain_sum is your DataFrame and it contains 'year' and 'rainfall' columns
years = jjs_rain_sum['year']
actual_rainfall = jjs_rain_sum['rainfall']

plt.figure(figsize=(12, 6))
plt.bar(years, actual_rainfall, color='blue', edgecolor='black')
plt.title('Yearly Rainfall from June to September')
plt.xlabel('Year')
plt.ylabel('Rainfall (mm)')
plt.grid(True)
plt.show()

from sklearn.model_selection import train_test_split
from sklearn.svm import SVR
from sklearn.metrics import mean_squared_error
actual_rainfall = jjs_rain_sum['rainfall']
years = jjs_rain_sum['year']
X = years.values.reshape(-1, 1)
y = actual_rainfall
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
svm_model = SVR(kernel='rbf')
svm_model.fit(X_train, y_train)
y_pred = svm_model.predict(X_test)
y_pred1 = svm_model.predict(X_train)

result_df_train = pd.DataFrame({'Year': X_train.flatten(), 'Actual Rainfall': y_train, 'Predicted Rainfall': y_pred1})
result_df_train['Absolute Error'] = abs(result_df_train['Actual Rainfall'] - result_df_train['Predicted Rainfall'])
result_df_train

result_df_train['Percentage error'] = (result_df_train['Absolute Error'] / result_df_train['Actual Rainfall']) * 100
result_df_train

result_df_train['Percentage error'].mean()

from matplotlib import pyplot as plt
import seaborn as sns
def _plot_series(series, series_name, series_index=0):
  palette = list(sns.palettes.mpl_palette('Dark2'))
  xs = series['Year']
  ys = series['Predicted Rainfall']

  plt.plot(xs, ys, label=series_name, color=palette[series_index % len(palette)])

fig, ax = plt.subplots(figsize=(10, 5.2), layout='constrained')
df_sorted = result_df_train.sort_values('Year', ascending=True)
_plot_series(df_sorted, '')
sns.despine(fig=fig, ax=ax)
plt.xlabel('Year')
_ = plt.ylabel('Predicted Rainfall')
plt.title('Predicted by SVM')
plt.legend()
plt.grid(True)
plt.show()

result_df = pd.DataFrame({'Year': X_test.flatten(), 'Actual Rainfall': y_test, 'Predicted Rainfall': y_pred})
result_df['Absolute Error'] = abs(result_df['Actual Rainfall'] - result_df['Predicted Rainfall'])
result_df['Percentage error'] = (result_df['Absolute Error'] / result_df['Actual Rainfall']) * 100
result_df

import matplotlib.pyplot as plt
import seaborn as sns

def _plot_series(series, series_name, series_index=0):
    palette = list(sns.palettes.mpl_palette('Dark2'))
    xs = series['Year']
    ys = series['Predicted Rainfall']

    plt.bar(xs, ys, label=series_name, color=palette[series_index % len(palette)])

# Create a figure and axis with constrained layout
fig, ax = plt.subplots(figsize=(10, 5.2), layout='constrained')

# Assuming _df_3 is your DataFrame containing 'Year' and 'Predicted Rainfall' columns
df_sorted = result_df.sort_values('Year', ascending=True)

# Plot the bar graph
_plot_series(df_sorted, 'Predicted Rainfall')

# Add plot details
sns.despine(fig=fig, ax=ax)
plt.xlabel('Year')
plt.ylabel('Predicted Rainfall')
plt.title('Predicted Rainfall Over Years')
plt.legend()
plt.grid(True)
plt.show()

df_combined = pd.concat([result_df, result_df_train], ignore_index=True)
df_combined

def _plot_series(series, series_name, series_index=0):
    palette = list(sns.palettes.mpl_palette('Dark2'))
    xs = series['Year']
    ys = series['Percentage error']

    plt.bar(xs, ys, label=series_name, color=palette[series_index % len(palette)])

# Create a figure and axis with constrained layout
fig, ax = plt.subplots(figsize=(10, 5.2), layout='constrained')

# Assuming _df_3 is your DataFrame containing 'Year' and 'Predicted Rainfall' columns
df_sorted = df_combined.sort_values('Year', ascending=True)

# Plot the bar graph
_plot_series(df_sorted, 'Predicted Rainfall')

# Add plot details
sns.despine(fig=fig, ax=ax)
plt.xlabel('Year')
plt.ylabel('Percentage Error')
plt.title('Error Over Years')
plt.legend()
plt.grid(True)
plt.show()

df_combined['Percentage error'].mean()

import matplotlib.pyplot as plt
import seaborn as sns

def _plot_series(series, series_name, series_index=0):
    palette = list(sns.color_palette('Dark2'))
    xs = series['Year']
    ys = series['Predicted Rainfall']

    plt.plot(xs, ys, label=series_name, color=palette[series_index % len(palette)])

# Create a figure and axis with constrained layout
fig, ax = plt.subplots(figsize=(10, 5.2), layout='constrained')

# Sort both DataFrames by 'Year'
df_sorted_train = result_df_train.sort_values('Year', ascending=True)
df_sorted_test = result_df.sort_values('Year', ascending=True)

# Plot both time series
_plot_series(df_sorted_train, 'Training Set', series_index=0)
_plot_series(df_sorted_test, 'Test Set', series_index=1)

# Add plot details
sns.despine(fig=fig, ax=ax)
plt.xlabel('Year')
plt.ylabel('Predicted Rainfall')
plt.title('Time Series of Predicted Rainfall Values')
plt.legend()
plt.grid(True)
plt.show()

result_df['error'] = abs(result_df['Actual Rainfall'] - result_df['Predicted Rainfall'])
result_df

mean = abs(df_combined['Absolute Error']).mean()
mean

predicted_rainfall = result_df['Predicted Rainfall']
plt.figure(figsize=(10, 6))
plt.hist(predicted_rainfall, bins=10, color='green', edgecolor='black')
plt.title('Histogram of Predicted Rainfall')
plt.xlabel('Predicted Rainfall (mm)')
plt.ylabel('Frequency')
plt.grid(True)
plt.show()

"""# polynimial regression model"""

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import PolynomialFeatures
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error
actual_rainfall = jjs_rain_sum['rainfall']
years = jjs_rain_sum['year']
X = years.values.reshape(-1, 1)
y = actual_rainfall
poly = PolynomialFeatures(degree=3)
X_poly = poly.fit_transform(X)
X_train, X_test, y_train, y_test = train_test_split(X_poly, y, test_size=0.2, random_state=42)
poly_model = LinearRegression()
poly_model.fit(X_train, y_train)
y_pred = poly_model.predict(X_test)
y_pred_train = poly_model.predict(X_train)

result_df_train_poly = pd.DataFrame({
    'Year': X_train[:, 1],
    'Actual Rainfall': y_train,
    'Predicted Rainfall': y_pred_train
})
result_df_train_poly['Error'] = abs(result_df_train_poly['Actual Rainfall'] - result_df_train_poly['Predicted Rainfall'])
result_df_train_poly

X_test_years = X_test[:, 1]
result_df_poly = pd.DataFrame({
    'Year': X_test_years,
    'Actual Rainfall': y_test.values,
    'Predicted Rainfall': y_pred
})
result_df_poly['Error'] = abs(result_df_poly['Actual Rainfall'] - result_df_poly['Predicted Rainfall'])
result_df_poly

df_combine = pd.concat([result_df_poly, result_df_train_poly], ignore_index=True)
df_combine['Percentage Error'] = (df_combine['Error'] / df_combine['Actual Rainfall']) * 100
df_combine

df_combine['Percentage Error'].mean()

import matplotlib.pyplot as plt

# Assuming df_combined is already defined and contains 'Year' and 'Rainfall' columns
df_combine.groupby('Year')['Percentage Error'].sum().plot(kind='bar', title='Error per Year')

# Customize plot aesthetics
ax = plt.gca()
ax.set_xlabel('Year')
ax.set_ylabel('Total Rainfall')
ax.spines['top'].set_visible(True)
ax.spines['right'].set_visible(True)

# Show the plot
plt.show()

from matplotlib import pyplot as plt
result_df_poly.plot(kind='scatter', x='Year', y='Predicted Rainfall', s=32, alpha=.8)
plt.gca().spines[['top', 'right',]].set_visible(False)

from matplotlib import pyplot as plt
import seaborn as sns

def _plot_series(series, series_name, series_index=0):
    palette = list(sns.palettes.mpl_palette('Dark2'))
    xs = series['Year']
    ys = series['Rainfall']

    plt.plot(xs, ys, label=series_name, color=palette[series_index % len(palette)])

fig, ax = plt.subplots(figsize=(10, 5.2), layout='constrained')

# Sorting the dataframes by year
df_sorted_predicted = result_df_poly.sort_values('Year', ascending=True)
df_sorted_actual = jjs_rain_sum.sort_values('year', ascending=True)

# Rename columns for consistency
df_sorted_actual.rename(columns={'year': 'Year', 'rainfall': 'Rainfall'}, inplace=True)
df_sorted_predicted.rename(columns={'Predicted Rainfall': 'Rainfall'}, inplace=True)

# Plotting predicted rainfall
_plot_series(df_sorted_predicted, 'Predicted Rainfall', series_index=0)

# Plotting actual rainfall
_plot_series(df_sorted_actual, 'Actual Rainfall', series_index=1)

sns.despine(fig=fig, ax=ax)
plt.xlabel('Year')
plt.ylabel('Rainfall (mm)')
plt.title('Year vs Predicted and Actual Rainfall')

# Adding legend
plt.legend()

# Rotate the x-ticks for better readability
plt.xticks(rotation=45)

plt.show()

import matplotlib.pyplot as plt
import seaborn as sns

def _plot_series(series, series_name, series_index=0):
    palette = list(sns.palettes.mpl_palette('Dark2'))
    xs = series['Year']
    ys = series['Actual Rainfall']

    plt.bar(xs, ys, label=series_name, color=palette[series_index % len(palette)], width=0.8)

fig, ax = plt.subplots(figsize=(10, 5.2), layout='constrained')
df_sorted = df_combine.sort_values('Year', ascending=True)
_plot_series(df_sorted, '')

sns.despine(fig=fig, ax=ax)
plt.xlabel('Year')
plt.ylabel('Predicted Rainfall')
plt.title('Year vs Predicted Rainfall')

# Rotate the x-ticks for better readability
plt.xticks(rotation=45)

plt.show()

plt.figure(figsize=(10, 6))
plt.plot(jjs_rain_sum['year'], jjs_rain_sum['rainfall'], label='Actual Rainfall', color='blue', marker='o')
plt.scatter(result_df_poly['Year'], result_df_poly['Predicted Rainfall'], color='red', label='Predicted Rainfall')
plt.plot(result_df_poly['Year'], result_df_poly['Predicted Rainfall'], color='red', linestyle='--', alpha=0.5)
plt.xlabel('Year')
plt.ylabel('Rainfall (mm)')
plt.title('Actual vs Predicted Rainfall using Polynomial Regression')
plt.legend()
plt.grid(True)
plt.show()

"""# random forest"""

from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error
X = years.values.reshape(-1, 1)
y = actual_rainfall
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
rf_model = RandomForestRegressor(n_estimators=10, random_state=42, oob_score = True)
rf_model.fit(X_train, y_train)
y_pred = rf_model.predict(X_test)
y_pred_train = rf_model.predict(X_train)

result_df_train_rf = pd.DataFrame({'Year': X_train.flatten(), 'Actual Rainfall': y_train, 'Predicted Rainfall': y_pred_train})
result_df_train_rf['Error'] = abs(result_df_train_rf['Actual Rainfall'] - result_df_train_rf['Predicted Rainfall'])
result_df_train_rf

result_df = pd.DataFrame({'Year': X_test.flatten(), 'Actual Rainfall': y_test, 'Predicted Rainfall': y_pred})

absolute_error = abs(result_df['Actual Rainfall'] - result_df['Predicted Rainfall'])
result_df['Error'] = absolute_error
result_df

df_combine_rf = pd.concat([result_df, result_df_train_rf], ignore_index=True)
df_combine_rf['Percentage Error'] = (df_combine_rf['Error'] / df_combine_rf['Actual Rainfall']) * 100
df_combine_rf

plt.figure(figsize=(10, 6))
plt.bar(df_combine_rf['Year'], df_combine_rf['Percentage Error'], color='blue')

# Customize the plot
plt.title('Percentage Error per Year')
plt.xlabel('Year')
plt.ylabel('Percentage Error')
plt.grid(axis='y', linestyle='--', alpha=0.7)

# Show the plot
plt.show()

import altair as alt

chart = alt.Chart(df_combined).mark_bar().encode(
    x='Year:O',
    y='Actual Rainfall'
).properties(
    title='Actual Rainfall per Year'
)

chart

import altair as alt
chart = alt.Chart(df_combine_rf).mark_line().encode(x='Year', y='Predicted Rainfall')
chart

df_combine_rf['Percentage Error'].mean()

result_df['Absolute Error'].mean()

plt.figure(figsize=(12, 6))
plt.plot(jjs_rain_sum['year'], jjs_rain_sum['rainfall'], label='Actual Rainfall', color='blue', marker='o')
plt.plot(result_df['Year'], result_df['Predicted Rainfall'], color='red', label='Predicted Rainfall', linestyle='--')
plt.scatter(result_df['Year'], result_df['Predicted Rainfall'], color='red', label='Predicted Rainfall')
plt.title('Year vs Rainfall (Actual and Predicted) By Random Forest')
plt.xlabel('Year')
plt.ylabel('Rainfall (mm)')
plt.legend()
plt.grid(True)
plt.show()

"""# linear regression

"""

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
actual_rainfall = jjs_rain_sum['rainfall']
years = jjs_rain_sum['year']
X = jjs_rain_sum[['year']]
y = jjs_rain_sum['rainfall']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
lr_model = LinearRegression()
lr_model.fit(X_train, y_train)
y_pred = lr_model.predict(X_test)
y_pred2 = lr_model.predict(X_train)

result_df_train_lr = pd.DataFrame({'Year': X_train.values.flatten(), 'Actual Rainfall': y_train, 'Predicted Rainfall': y_pred2})
result_df_train_lr['Absolute Error'] = abs(result_df_train['Actual Rainfall'] - result_df_train['Predicted Rainfall'])
result_df_train_lr



result_df_train_lr_combined = pd.concat([result_df_train_lr, result_df], ignore_index=False)
result_df_train_lr_combined

# Plot the bar graph
plt.figure(figsize=(10, 6))
plt.bar(result_df_train_lr_combined['Year'], result_df_train_lr_combined['Actual Rainfall'], color='blue')
plt.xlabel('Year')
plt.ylabel('Actual Rainfall')
plt.title('Actual Rainfall by Year')
plt.xticks(rotation=45)  # Rotate x-axis labels for better readability
plt.grid(axis='y', linestyle='--', alpha=0.7)  # Add gridlines for better readability
plt.tight_layout()

from matplotlib import pyplot as plt
import seaborn as sns
def _plot_series(series, series_name, series_index=0):
  palette = list(sns.palettes.mpl_palette('Dark2'))
  xs = series['Year']
  ys = series['Predicted Rainfall']

  plt.plot(xs, ys, label=series_name, color=palette[series_index % len(palette)])
fig, ax = plt.subplots(figsize=(10, 5.2), layout='constrained')
df_sorted = result_df_train_lr_combined.sort_values('Year', ascending=True)
_plot_series(df_sorted, '')
sns.despine(fig=fig, ax=ax)
plt.xlabel('Year')
_ = plt.ylabel('Predicted Rainfall')

plt.title('Predicted by Linear Regression')
plt.legend()
plt.grid(True)
plt.show()

result_df_train_lr_combined['Percentage error'] = (result_df_train_lr_combined['Absolute Error'] / result_df_train_lr_combined['Actual Rainfall']) * 100
result_df_train_lr_combined['Percentage error'].mean()

# Plot the bar graph
plt.figure(figsize=(10, 6))
plt.bar(result_df_train_lr_combined['Year'], result_df_train_lr_combined['Percentage error'], color='blue')
plt.xlabel('Year')
plt.ylabel('Percentage error')
plt.title('Percentage error by Year')
plt.xticks(rotation=45)  # Rotate x-axis labels for better readability
plt.grid(axis='y', linestyle='--', alpha=0.7)  # Add gridlines for better readability
plt.tight_layout()



result_df['Absolute Error'].mean()

plt.figure(figsize=(10, 6))
plt.plot(jjs_rain_sum['year'], jjs_rain_sum['rainfall'], label='Actual Rainfall', color='blue', marker='o')
plt.plot(result_df['Year'], result_df['Predicted Rainfall'], label='Predicted Rainfall', color='red', linestyle='--')
plt.scatter(result_df['Year'], result_df['Predicted Rainfall'], color='red', label='Predicted Rainfall')
plt.xlabel('Year')
plt.ylabel('Rainfall')
plt.title('Actual and Predicted by Linear Regression')
plt.legend()
plt.grid(True)
plt.show()