# -*- coding: utf-8 -*-
"""XGBOOST.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/147FxPk2w4NLAZycijWki2HjvTA1QVYZ8
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from google.colab import drive
drive.mount('/content/drive')
df = pd.read_csv('/content/drive/MyDrive/POWER_Point_Daily_19810101_20240430_012d97N_077d59E_LST (1).csv')
df

df = df.drop(df.index[:19])
select = ['-BEGIN HEADER-','Unnamed: 1','Unnamed: 5']
ndf = df[select]
cols = ['year','dayno.','rainfall']
ndf.columns = cols
ndf.head()

ndf.loc[:, 'rainfall'] = ndf['rainfall'].astype(float)
ndf.loc[:, 'year'] = ndf['year'].astype(int)
total = ndf['rainfall'].sum()
total

ndf = ndf.groupby("year")['rainfall'].sum()
ndf = ndf.reset_index()
ndf

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from xgboost import XGBRegressor
from sklearn.metrics import mean_squared_error
X = ndf[['year']]
y = ndf['rainfall']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)
xgb_model = XGBRegressor(n_estimators=100, learning_rate=0.1, max_depth=3, random_state=42)
xgb_model.fit(X_train_scaled, y_train)
y_pred = xgb_model.predict(X_test_scaled)
y_pred_train = xgb_model.predict(X_train_scaled)

result_df_train_xg = pd.DataFrame({'Year': X_train.values.flatten(), 'Actual Rainfall': y_train, 'Predicted Rainfall': y_pred_train})
result_df_train_xg['Absolute Error'] = abs(result_df_train_xg['Actual Rainfall'] - result_df_train_xg['Predicted Rainfall'])
result_df_train_xg

from sklearn.metrics import r2_score

r2 = r2_score(y_test, y_pred)
print(f"R-squared: {r2}")

predicted_df = pd.DataFrame({
    'Year': X_test['year'],
    'Actual Rainfall': y_test,
    'Predicted Rainfall': y_pred
})
predicted_df

predicted_df['Absolute Error'] = abs(predicted_df['Predicted Rainfall'] - predicted_df['Actual Rainfall'])
predicted_df

result_combine = pd.concat([result_df_train_xg, predicted_df])
result_combine

# prompt: Using dataframe result_combine: actual rain
# vs year bar grabh

import altair as alt

chart = alt.Chart(result_combine).mark_bar().encode(
    x = 'Year',
    y = 'Actual Rainfall',

).properties(
    width=600
)

chart

result_combine['Percentage Error'] = abs(result_combine['Actual Rainfall'] - result_combine['Predicted Rainfall']) / result_combine['Actual Rainfall'] * 100
result_combine

result_combine['Percentage Error'].mean()

"""# JJAS ANALYSIS

"""

jjas_df = pd.read_csv('/content/drive/MyDrive/POWER_Point_Daily_19810101_20240430_012d97N_077d59E_LST (1).csv')

select = ['-BEGIN HEADER-','Unnamed: 1','Unnamed: 5']
ndf = df[select]
cols = ['year','dayno.','rainfall']
ndf.columns = cols
ndf.head()
ndf.loc[:, 'rainfall'] = ndf['rainfall'].astype(float)
ndf.loc[:, 'year'] = ndf['year'].astype(int)
total = ndf['rainfall'].sum()
ndf['dayno.'] = ndf['dayno.'].astype(int)
selected_days = ndf[(ndf['dayno.'] >= 150) & (ndf['dayno.'] <= 250)]
jjs_rain_sum = selected_days.groupby('year')['rainfall'].sum().reset_index()
jjs_rain_sum.head()

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from xgboost import XGBRegressor
from sklearn.metrics import mean_squared_error
X = jjs_rain_sum[['year']]
y = jjs_rain_sum['rainfall']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)
xgb_model = XGBRegressor(n_estimators=100, learning_rate=0.1, max_depth=3, random_state=42)
xgb_model.fit(X_train_scaled, y_train)
y_pred = xgb_model.predict(X_test_scaled)
y_pred_train = xgb_model.predict(X_train_scaled)

X_train = X_train.values.flatten()
result_df_train = pd.DataFrame({'Year': X_train, 'Actual Rainfall': y_train, 'Predicted Rainfall': y_pred_train})
result_df_train['Absolute Error'] = abs(result_df_train['Actual Rainfall'] - result_df_train['Predicted Rainfall'])
result_df_train

predicted_df = pd.DataFrame({
    'Year': X_test['year'],
    'Actual Rainfall': y_test,
    'Predicted Rainfall': y_pred
})

predicted_df['Absolute Error'] = abs(predicted_df['Predicted Rainfall'] - predicted_df['Actual Rainfall'])
predicted_df

combine_jjas = pd.concat([result_df_train, predicted_df])
combine_jjas['Percentage Error'] = (combine_jjas['Absolute Error'] / combine_jjas['Actual Rainfall']) * 100
combine_jjas.head()

import altair as alt

chart = alt.Chart(combine_jjas).mark_bar().encode(
    x = alt.X('Year:N', title='Year'),
    y = alt.Y('Actual Rainfall:Q', title='Rainfall (mm)'),
    color = alt.Color('Actual Rainfall:Q', legend=None)
).properties(
    width=600,
    height=400
)

chart

import altair as alt
alt.Chart(combine_jjas).mark_line().encode(
    x='Year',
    y='Predicted Rainfall'
).properties(width=600)

import altair as alt

chart = alt.Chart(combine_jjas).mark_bar().encode(
    x = alt.X('Year', title='Year'),
    y = alt.Y('Percentage Error', title='Percentage Error')
).properties(
    width=600
)

chart

combine_jjas['Percentage Error'].mean()

"""#JUNE ANALYSIS"""

select = ['-BEGIN HEADER-','Unnamed: 1','Unnamed: 5']
ndf = df[select]
cols = ['year','dayno.','rainfall']
ndf.columns = cols
ndf.head()

ndf.loc[:, 'rainfall'] = ndf['rainfall'].astype(float)
ndf.loc[:, 'year'] = ndf['year'].astype(int)
total = ndf['rainfall'].sum()

ndf['dayno.'] = ndf['dayno.'].astype(int)
selected_days = ndf[(ndf['dayno.'] >= 150) & (ndf['dayno.'] <= 180)]
june_rain_sum = selected_days.groupby('year')['rainfall'].sum().reset_index()
june_rain_sum

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from xgboost import XGBRegressor
from sklearn.metrics import mean_squared_error
X = june_rain_sum[['year']]
y = june_rain_sum['rainfall']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)
xgb_model = XGBRegressor(n_estimators=100, learning_rate=0.1, max_depth=3, random_state=42)
xgb_model.fit(X_train_scaled, y_train)
y_pred = xgb_model.predict(X_test_scaled)
y_pred_train_june = xgb_model.predict(X_train_scaled)

result_train_june = pd.DataFrame({'Year': X_train.values.flatten(), 'Actual Rainfall': y_train, 'Predicted Rainfall': y_pred_train_june})
result_train_june['Error'] = abs(result_train_june['Actual Rainfall'] - result_train_june['Predicted Rainfall'])
result_train_june

predicted_df = pd.DataFrame({
    'Year': X_test['year'],
    'Actual Rainfall': y_test,
    'Predicted Rainfall': y_pred
})
predicted_df['Error'] = abs(predicted_df['Predicted Rainfall'] - predicted_df['Actual Rainfall'])
predicted_df

combine_june = pd.concat([result_train_june, predicted_df])
combine_june['Percentage Error'] = (combine_june['Error'] / combine_june['Actual Rainfall']) * 100
combine_june.head()

import pandas as pd
import altair as alt

# convert dataframe to long format
df_long = combine_june.melt(id_vars=['Year'], value_vars=['Actual Rainfall', 'Predicted Rainfall'], var_name='Rainfall Type')

# create bar chart
chart = alt.Chart(df_long).mark_bar().encode(
    x='Year',
    y='value'
).properties(width=600)

# display chart
chart

import altair as alt
alt.Chart(combine_june).mark_line().encode(
    x='Year',
    y='Predicted Rainfall'
).properties(
    title='Predicted Rainfall vs Year'
)

import altair as alt
chart = alt.Chart(combine_june).mark_bar().encode(x='Year', y='Percentage Error', color='Year')
chart

combine_june['Percentage Error'].mean()

"""#july rainfall"""

ndf['dayno.'] = ndf['dayno.'].astype(int)
selected_days = ndf[(ndf['dayno.'] >= 180) & (ndf['dayno.'] <= 210)]
july_rain_sum = selected_days.groupby('year')['rainfall'].sum().reset_index()
july_rain_sum

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from xgboost import XGBRegressor
from sklearn.metrics import mean_squared_error
X = july_rain_sum[['year']]
y = july_rain_sum['rainfall']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)
xgb_model = XGBRegressor(n_estimators=100, learning_rate=0.1, max_depth=3, random_state=42)
xgb_model.fit(X_train_scaled, y_train)
y_pred = xgb_model.predict(X_test_scaled)
y_pred_train_july = xgb_model.predict(X_train_scaled)

result_train_july = pd.DataFrame({'Year': X_train.values.flatten(), 'Actual Rainfall': y_train, 'Predicted Rainfall': y_pred_train_july})
result_train_july['Error'] = abs(result_train_july['Actual Rainfall'] - result_train_july['Predicted Rainfall'])
result_train_july

predicted_df = pd.DataFrame({
    'Year': X_test['year'],
    'Actual Rainfall': y_test,
    'Predicted Rainfall': y_pred
})
predicted_df['Error'] = abs(predicted_df['Predicted Rainfall'] - predicted_df['Actual Rainfall'])
predicted_df

combine_july = pd.concat([result_train_july, predicted_df])
combine_july['Percentage Error'] = (combine_july['Error'] / combine_july['Actual Rainfall']) * 100
combine_july.head()

import altair as alt

chart = alt.Chart(combine_july).mark_line().encode(
    x='Year',
    y='Predicted Rainfall'
).properties(
    title='Predicted Rainfall vs Year'
)

chart

import altair as alt

chart = alt.Chart(combine_july).mark_bar().encode(
    x = 'Year:N',
    y = 'Actual Rainfall:Q'
)

chart

import altair as alt

alt.Chart(combine_july).mark_bar().encode(
    x='Year',
    y='Percentage Error',
    color='Year'
).properties(width=600)

combine_july['Percentage Error'].mean()

"""# AUGUST ANALYSIS"""

ndf['dayno.'] = ndf['dayno.'].astype(int)
selected_days = ndf[(ndf['dayno.'] >= 210) & (ndf['dayno.'] <= 240)]
aug_rain_sum = selected_days.groupby('year')['rainfall'].sum().reset_index()
aug_rain_sum

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from xgboost import XGBRegressor
from sklearn.metrics import mean_squared_error
X = aug_rain_sum[['year']]
y = aug_rain_sum['rainfall']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)
xgb_model = XGBRegressor(n_estimators=100, learning_rate=0.1, max_depth=3, random_state=42)
xgb_model.fit(X_train_scaled, y_train)
y_pred = xgb_model.predict(X_test_scaled)
y_pred_train_aug = xgb_model.predict(X_train_scaled)

result_train_august = pd.DataFrame({'Year': X_train.values.flatten(), 'Actual Rainfall': y_train, 'Predicted Rainfall': y_pred_train_aug})
result_train_august['Error'] = abs(result_train_august['Actual Rainfall'] - result_train_august['Predicted Rainfall'])
result_train_august

predicted_df = pd.DataFrame({
    'Year': X_test['year'],
    'Actual Rainfall': y_test,
    'Predicted Rainfall': y_pred
})
predicted_df['Error'] = abs(predicted_df['Predicted Rainfall'] - predicted_df['Actual Rainfall'])
predicted_df

combine_august = pd.concat([result_train_august, predicted_df])
combine_august['Percentage Error'] = (combine_august['Error'] / combine_august['Actual Rainfall']) * 100
combine_august.head()

import altair as alt

chart = alt.Chart(combine_august).mark_line().encode(
    x='Year',
    y='Predicted Rainfall'
).properties(
    title='Predicted Rainfall vs Year'
)
chart

import altair as alt

bar = alt.Chart(combine_august).mark_bar().encode(
    x = 'Year:N',
    y = 'Actual Rainfall:Q'
).properties(
    width=600
)

bar

import altair as alt
chart = alt.Chart(combine_august).mark_bar().encode(
    x = alt.X('Year:N', title='Year'),
    y = alt.Y('Percentage Error:Q', title='Percentage Error')
).properties(
    width=600
)
chart

combine_august['Percentage Error'].mean()

"""# SEPTEMBER ANALYSIS"""

ndf['dayno.'] = ndf['dayno.'].astype(int)
selected_days = ndf[(ndf['dayno.'] >= 240) & (ndf['dayno.'] <= 270)]
sep_rain_sum = selected_days.groupby('year')['rainfall'].sum().reset_index()
sep_rain_sum

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from xgboost import XGBRegressor
from sklearn.metrics import mean_squared_error
X = sep_rain_sum[['year']]
y = sep_rain_sum['rainfall']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)
xgb_model = XGBRegressor(n_estimators=100, learning_rate=0.1, max_depth=3, random_state=42)
xgb_model.fit(X_train_scaled, y_train)
y_pred = xgb_model.predict(X_test_scaled)
y_pred_train_sep = xgb_model.predict(X_train_scaled)

result_train_sep = pd.DataFrame({'Year': X_train.values.flatten(), 'Actual Rainfall': y_train, 'Predicted Rainfall': y_pred_train_sep})
result_train_sep['Error'] = abs(result_train_sep['Actual Rainfall'] - result_train_sep['Predicted Rainfall'])
result_train_sep

predicted_df = pd.DataFrame({
    'Year': X_test['year'],
    'Actual Rainfall': y_test,
    'Predicted Rainfall': y_pred
})
predicted_df['Error'] = abs(predicted_df['Predicted Rainfall'] - predicted_df['Actual Rainfall'])
predicted_df

combine_sep = pd.concat([result_train_sep, predicted_df])
combine_sep['Percentage Error'] = (combine_sep['Error'] / combine_sep['Actual Rainfall']) * 100
combine_sep.head()

import altair as alt

chart = alt.Chart(combine_sep).mark_line().encode(
    x='Year',
    y='Predicted Rainfall'
).properties(
    title='Predicted Rainfall vs Year'
)
chart

import altair as alt

bar = alt.Chart(combine_sep).mark_bar().encode(
    x = 'Year:N',
    y = 'Actual Rainfall:Q'
).properties(
    width=600
)

bar

import altair as alt
chart = alt.Chart(combine_sep).mark_bar().encode(
    x = alt.X('Year:N', title='Year'),
    y = alt.Y('Percentage Error:Q', title='Percentage Error')
).properties(
    width=600
)
chart

combine_sep['Percentage Error'].mean()